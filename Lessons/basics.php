<?php

namespace Lessons\Basics;

use Classes\L_1_24;

/* 1.1 Элементарная единица PHP кода называется оператором. Оператор завершается символом 'точка с запятой', который
 * означает конец оператора. На одной строке можно располагать несколько операторов. Один оператор можно располагать на
 * нескольких строках. Возможен пустой оператор, который не содержит никаких символов. */
function punctuation()
{
    $first = 1; $second = 2;
    $third = 3;
    $fourth
        = 4;
    ; ;;
}

/* 1.2 В PHP режим кода изначально отключен. Это значит что интерпретатор воспринимает файлы с расширением .php как
 * текст. Чтобы включить режим кода существует несколько способов:
 * - cтандартный тег: <?php ?>
 * - тег script: <script language="php"> </script>
 * - сокращенный тег: <?= ?>
 * - еще один сокращенный тег: <% %>
 * Не рекомендуется использовать два последних варианта.
 */
function tags()
{
    /* Выходим из режима кода в режим текста  */ ?>

    <b> Здесь нет PHP, только HTML </b>

    <script language="php">
        /* Снова входим в режим кода */
        echo "Здесь PHP снова работает \n";
        /* Выходим из режима кода в режим текста  */
    </script>

   <?php /* снова входим в режим кода */
}

/* 1.3 Существует три вида комментариев в php.
 * Все они представлены ниже. */
function comments()
{
    // Это однострочный комментарий, продолжающийся до конца строки

    # Это еще один однострочный комментарий, тоже продожающийся до конца строки

    /* Это многострочный комментарий
    который может распространяться на
    несколько строк */

    /* Или присутствовать */ /* сразу в нескольких местах */ /* на одной строке */

    // /* /* Нельзя вкладывать многострочные комментарии друг в друга, это приведет к ошибке */ */
}

/* 1.4 Арифметические операторы php - сложение, вычитание, умножение,
 * деление, остаток от деления. */
function arithmeticOperators()
{
    $add = 2 + 2; // 4
    $sub = 4 - 2; // 2
    $mul = 3 * 3; // 9
    $div = 10 / 3.33; // 3.003003003003

    echo "add = {$add}; sub = {$sub}; mul = {$mul}; div = {$div};\n";

    /* Оператор остатка от деления работает только с целыми числами.
     * Если передать ему число с плавающей точкой,
     * то от этого числа просто будет отброшена дробная часть. */
    $rest1 = 10 % 3; // 1
    $rest2 = 10 % 3.33; // 1 потому что 3.33 будет приведено к 3
    $rest3 = 10.6 % 3; // 1 потому что 10.6 будет приведено к 10

    /* Оператор остатка от деления возвращает отрицательный результат в том случае,
     * если первое число отрицательное. */
    $rest4 = -20 % 3; // -2 потому что -20 отрицательное значение

    echo "rest1 = {$rest1}; rest2 = {$rest2}; rest3 = {$rest3}; rest4 = {$rest4}\n";
}

/* 1.6 Операторы присваивания - +=, -=, *=, /= ...
 * и т. д. А также конкатенация, инкремент и декремент. */
function assignmentOperators()
{
    // Приваивание и арифметические операции
    $add = 10; $sub = 10; $mul = 10; $div = 10; $rest = 10;
    $add += 2; // 12
    $sub -= 3; // 7
    $mul *= 2; // 20
    $div /= 4; // 2.5
    $rest %= 3; // 1
    echo "add = {$add}; sub = {$sub}; mul = {$mul}; div = {$div}; rest = {$rest};\n";

    // Присваивание и побитовые операции
    $and = bindec('1100');
    $and &= bindec('1010');
    $and = decbin($and); // 1000

    $or = bindec('1100');
    $or |= bindec('1010');
    $or = decbin($or); // 1110

    $xor = bindec('1100');
    $xor ^= bindec('1010');
    $xor = decbin($xor); // 0110

    $lshift = bindec('11111111');
    $lshift <<= 2;
    $lshift = decbin($lshift); // 1111111100

    $rshift = bindec('11111111');
    $rshift >>= 2;
    $rshift = decbin($rshift); // 111111

    echo "and = {$and}; or = {$or}; xor = {$xor}; lshift = {$lshift}; rshift = {$rshift};\n";

    // Присваивание и строковые операции
    $str = 'Hello ';
    $str .= ' world';
    echo "str = {$str};\n";

    // Присваивание элементов массива (оператор стрелка)
    $a = ['a' => 1, 'b' => 2];
    echo print_r($a, True), PHP_EOL;

    /* Инкремент ++ увеличивает значение на единицу
     * Декремент -- уменьшает значение на единицу
     * Здесь показан постинкремент и постдекремент */
    $n1 = 1;
    $n2 = 3;
    $n1++; // 2
    $n2--; // 2

    /* Разница между пре и постинкрементом (декрементом) в том
     * что пре***ремент изменяет значение а затем возвращает
     * а пос***ремент возвращает значение а затем изменяет.  */
    $x3 = 4;
    $x4 = 4;
    $n3 = ++$x3 * 2; // (4 + 1) * 2 = 10, здесь переменная x3 увеличит значение до 5 а затем выполнятся остальные рассчеты
    $n4 = $x4++ * 2; // 4 * 2 =, 8 здесь переменная x4 будет использована в рассчетах как есть, и лишь после их выполнения будет увеличена

    echo "n1 = {$n1}; n2 = {$n2}; n3 = {$n3}; n4 = {$n4};\n";
}

/* 1.7 Операторы сравнения - равно, не равно, больше, меньше, больше или равно,
 * меньше или равно, идентично, не идентично */
function comparisonOperators()
{
    /* Операторы == и != сравнивают без учета типа.
     * Таким образом 0, False, '', '0', '0.0', 0.0 приводятся к одному значению. */
    $a = (0 == False) && (0 == '') && (0 == '0') && (0 == 0.0) && (0 == '0.0'); // True
    $b = (5 == True) && (5 == '5') && (5 == 5.0) && (5 == '5.0'); // True
    $с = (7 != 10); // True

    echo "a = {$a}; b = {$b}; с = {$с};\n";

    /* Операторы иднтичности === и !== сравнивают с учетом типа.
     * Таким образом 0, False, '', '0', '0.0', 0.0 все не идентичны друг другу. */
    $a = (0 === False) || (0 === '') || (0 === '0') || (0 === 0.0) || (0 === '0.0'); // False
    $b = (5 === True) || (5 === '5') || (5 === 5.0) || (5 === '5.0'); // False
    $с = (7 !== 10); // True

    echo "a = {$a}; b = {$b}; с = {$с};\n";

    $a = 2 > 1; // True
    $b = 1 < 2; // True
    $c = 1 >= 1; // True
    $d = 2 <= 2; // True
    $e = 2 <> 1; // True, аналогичен оператору !=

    echo "a = {$a}; b = {$b}; с = {$c}; d = {$d}; e = {$e};\n";
}

/* 1.8 Строковые операторы - конкатенация и
 * сокращенная форма конкатенации */
function stringOperators()
{
    // конкатенация
    $phrase1 = 'hello ' . 'world ' . '!!!';

    // сокращенная форма конкатенации
    $phrase2 = 'HELLO ';
    $phrase2 .= 'WORLD ';
    $phrase2 .= '!!!';

    echo "{$phrase1}\n{$phrase2}\n";
}

/* 1.11 Оператор выполнения. Предназначен для передачи команд
 * в операционную систему. */
function executionOperators()
{
    /* передаем команду в командную строку, получаем и выводим результат */
    $result = `ls -l`;
    echo "$result\n";

    /* то же самое, но с помощью функции shell_exec */
    $result = shell_exec('ls -l');
    echo "$result\n";
}

/* 1.13 Переменные это именованные области памяти, предназначенные
 * для хранения некоторых значений (чисел, строк, объектов). Имена
 * переменных в PHP начинаются со знака $ (доллар). */
function variablesNaming()
{
    /* После знака $ в имени переменной обязательно должна идти буква либо знак
     * подчеркивания. Начиная с третьего символа также может быть цифра.
     * Прочие символы в именах переменных недопустимы. */
    $www = 10;
    $яяя = 11; // допустимы буквы любого алфавита, в том числе и кириллица
    $_xx = 22;
    $_99_ = 99;

    /* Эти имена переменных недопустимы */
    // $33 = 23; // Потому что начинается с цифры
    // $a:24 = 27; // Потому что в имени есть недопустимый символ (двоеточие)

    /* Имена переменных регистрозависимы. Ниже представлены разные переменные,
     * хоть их имена и отличаются только регистром. */
    $x = 10; $X = 11;
    echo "x = {$x}; X = {$X};\n";
}

/* 1.14 Если нужно, чтобы две переменные указывали на одни и те же данные,
 * используется механизм ссылок. */
function variablesReferencing()
{
    // a и b оба указывают на одну область памяти, в которой находится число 10
    $a = 10;
    $b =& $a; // используем оператор присваивания по ссылке
    echo "a = {$a}; b = {$b};\n";

    // изменим значение через переменную a и убедимся, что b тоже изменилась
    $a = 15;
    echo "a = {$a}; b = {$b};\n";

    // изменим значение через переменную b и убедимся, что a тоже изменилась
    $b = 20;
    echo "a = {$a}; b = {$b};\n";
}

/* 1.15 Инициализация переменных. Проверка инициализации
 * переменных. */
function variablesInitializing()
{
    /* Неинициализированная переменная по умолчанию имеет значение NULL */
    $type_a = gettype($a);
    echo "type of a = {$type_a};\n";

    /* Что бы проверить, была ли переменная инициализирована, используем функцию isset() */
    echo isset($a) ? "a is set\n" : "a is not set\n";

    /* Если переменной принудительно присвоить значение Null, она будет считатся неинициализированной */
    $b = Null;
    echo isset($b) ? "b is set\n" : "b is not set\n";

    /* Переменные, которые содержат 0, False, '' считаются инициализированными */
    $c = False;
    echo isset($c) ? "c is set\n" : "c is not set\n";
}

/* 1.16 Операторы ветвления позволяют выбрать выполняемые действия в зависимости от
 * результат проверки условия. Операторов ветвления три: if, switch и тернарный оператор */
function conditions()
{
    _conditionsIf();
    _conditionsSwitch();
    _conditionsTernary();
}

function _conditionsIf()
{
    /* Оператор ветвления if состоит из трех частей if, else if, else.
     * Только первая из них обязательна, остальные опциональны. */
    $population = rand(30, 1000000);

    if ($population >= 30 && $population < 300) {
        echo "This is a little village.\n";
    }

    /* else if может писаться раздельно */
    else if ($population >=300 && $population < 1000) {
        echo "This is a big village.\n";
    }

    /* elseif может писаться слитно */
    elseif ($population >= 1000 && $population < 10000) {
        echo "This is a town.\n";
    }

    /* Если нужно выполнить всего один оператор,
     * то можно не заключать его в фигурные скобки. */
    else if ($population >= 10000 && $population < 500000)
        echo "This is a city. \n";

    /* Блок else должен быть в самом конце, после остальных условий */
    else
        echo "This is a big sity.\n";

    /* Пример опрератора ветвления if без else if и else */
    if (True) {
        echo "----------------\n";
    }
}

function _conditionsSwitch()
{
    /* Тернарный оператор похож на if-else, только значительно короче. */
    $age = rand(0, 30);
    $isChild = ($age < 16) ? "is a child\n" : "is not a child\n";
    echo $isChild;

    /* Существует также сокращенная форма тернарного оператора.
     * Если условие истинно, то возвращается оно. Иначе возвращатеся значение по умолчанию. */
    $value = (rand(0, 5)) ?: 'не выбрано';
    echo "{$value}\n";
}

function _conditionsTernary()
{
    /* switch проверяет переменную на соответсвие нескольким значениям */
    $d = 'Robert';

    switch ($d) {

        /* один обработчик для нескольких кейсов */
        case 'Robert':
        case 'Bob':
            echo 'Bob';
            break;

        /* если ни один кейс не подошел выполняется default (который может быть как в конце switch, так и нет) */
        default:
            echo 'another name';
            break;

        case 'Sally':
            echo 'Sally';
            break;
    }
}

/* 1.20 Функции (конструкции языка) isset, unset, list  */
function otherConstructs()
{
    $a = 10;

    /* isset() проверяет хранит ли переменная значение */
    if (isset($a)) {
        echo "Variable a has a value. \n";
    }

    /* unset() удаляет переменную (устанавливает в Null) */
    unset($a);

    if (!isset($a)) {
        echo "Variable a has not a value now. \n";
    }

    /* list() присваивает нескольким переменным значения из массива.
     * Отдельные элементы массива можно пропускать как показано ниже (yellow). */
    list($a, $b, $c, , $e) = ['red', 'green', 'blue', 'yellow', 'grey'];

    echo "a = {$a}; b = {$b}; c = {$c}; e = {$e}\n";
}

/* 1.21, 1.22, 1,23 Константы похожи на переменные, за исключением того,
 * что их значение можно определить только один раз (при создании) и
 * больше нельзя изменять. Константы определяются функцией define, либо
 * с помощью ключевого слова const. Однако const нельзя
 * использовать внутри функций а define для объявления констант класса. */
const CON_COLOR = 'RED';
define('CON_WEIGHT', 22);

function constants()
{
    // CON_WIDTH = 75; // внутри функций этот способ недоступен
    define('CON_HEIGHT', 44);

    /* Константы доступны в любом контексте в любом месте программы */
    echo CON_COLOR, '; ', CON_WEIGHT, '; ', CON_HEIGHT, ";\n";

    /* Правила именования констант такие-же как и для переменных, за исключением того,
     * что не используется знак доллара как первый символ.
     * Константы так же регистрозависимы, как и переменные. */
    define('con_height', 33);
    echo con_height, '; ', CON_HEIGHT, ";\n";
}

/* 1.24 Магические константы php устанавливает автоматически. Некоторые из них изменяют
 * свое значение в зависимости от места вызова. */
function magicConstants()
{
    // полное наименование файла текущего скрипта (включая путь)
    echo '__FILE__ = ' . __FILE__ . PHP_EOL; // PHP_EOL символ перехода на следующую строку

    // текущий каталог
    echo '__DIR__ = ' . __DIR__ . PHP_EOL;

    // номер строки кода
    echo '__LINE__ = ' . __LINE__ . PHP_EOL;

    // полное имя текущей функции (включая пространство имен)
    echo '__FUNCTION__ = ' . __FUNCTION__ . PHP_EOL;

    // имя текущего пространства имен
    echo '__NAMESPACE__ = ' . __NAMESPACE__ . PHP_EOL;

    // константы класса и метода (см. в файле класса)
    $th = new L_1_24\Thing();
    $th->get();
}